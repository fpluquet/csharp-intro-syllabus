# Les fonctions

## Concept de base

Imaginez une fonction comme une petite machine √† laquelle on confie une t√¢che pr√©cise. On lui fournit des √©l√©ments en entr√©e, elle ex√©cute des √©tapes bien d√©finies, puis elle nous renvoie √©ventuellement un r√©sultat. C'est une mani√®re d'organiser sa pens√©e et son code : on d√©coupe un probl√®me en gestes simples, r√©utilisables, et on leur donne un nom parlant.

Une **fonction** est un bloc d'instructions qui porte un nom, qui peut prendre des **param√®tres** en entr√©e et peut renvoyer une **valeur** en sortie.

**Pourquoi utiliser des fonctions ?**
- **Clarifier le code** en le d√©coupant en morceaux coh√©rents et faciles √† lire
- **√âviter la r√©p√©tition** (DRY: Don't Repeat Yourself) et donc r√©duire les erreurs
- **Nommer l'intention** : un bon nom raconte ce que fait le code
- **Tester plus facilement** chaque pi√®ce du programme, ind√©pendamment des autres

## D√©finition d'une fonction

### Exemple de signature simple

```csharp
void Affiche(string texte)
{
    Console.WriteLine(texte);
}
```

Pour appeler cette fonction :
```csharp
Affiche("Bonjour");
```

### Avec plusieurs param√®tres

```csharp
void AfficheNFois(string texte, int nb)
{
    for (int i = 0; i < nb; i++)
    {
        Console.WriteLine(texte);
    }
}
```

Pour appeler cette fonction :
```csharp
AfficheNFois("Bonjour", 4);
```

## Signature de fonction

La **signature d'une fonction** est sa carte d'identit√© : elle d√©crit pr√©cis√©ment comment identifier et utiliser cette fonction. Elle comprend :

1. **Le nom de la fonction**
2. **Le nombre de param√®tres**
3. **Le type de chaque param√®tre**
4. **L'ordre des param√®tres**

::: tip Important
Le **type de retour ne fait PAS partie de la signature** en C#. Deux fonctions ne peuvent pas avoir la m√™me signature m√™me si elles retournent des types diff√©rents.
:::

### Exemples de signatures

```csharp
// Signature : Affiche(string)
void Affiche(string texte)

// Signature : Addition(int, int)
int Addition(int a, int b)

// Signature : CalculerMoyenne(double, double, double)
double CalculerMoyenne(double note1, double note2, double note3)

// Signature : ConvertirEnMajuscules(string)
string ConvertirEnMajuscules(string texte)
```

### Signatures distinctes vs identiques

Ces fonctions ont des **signatures diff√©rentes** (surcharge valide) :
```csharp
void Afficher(int nombre)           // Signature : Afficher(int)
void Afficher(string texte)         // Signature : Afficher(string)  
void Afficher(int a, int b)         // Signature : Afficher(int, int)
void Afficher(string nom, int age)  // Signature : Afficher(string, int)
```

Ces fonctions ont la **m√™me signature** (erreur de compilation) :
```csharp
void Calculer(int a, int b)         // Signature : Calculer(int, int)
int Calculer(int x, int y)          // ‚ùå ERREUR ! M√™me signature
double Calculer(int nb1, int nb2)   // ‚ùå ERREUR ! M√™me signature
```

Le compilateur ne peut pas distinguer ces fonctions car elles ont la m√™me signature, m√™me si :
- Les noms des param√®tres sont diff√©rents (`a,b` vs `x,y` vs `nb1,nb2`)
- Les types de retour sont diff√©rents (`void` vs `int` vs `double`)

### Pourquoi la signature est-elle importante ?

1. **Identification unique** : la signature permet au compilateur de savoir quelle fonction appeler
2. **Surcharge de fonctions** : on peut avoir plusieurs fonctions avec le m√™me nom si leurs signatures sont diff√©rentes
3. **R√©solution d'appel** : le compilateur choisit automatiquement la bonne fonction selon les arguments fournis

```csharp
// Le compilateur choisit automatiquement selon les arguments
Afficher(42);           // Appelle Afficher(int)
Afficher("Hello");      // Appelle Afficher(string)
Afficher(1, 2);         // Appelle Afficher(int, int)
Afficher("Alice", 25);  // Appelle Afficher(string, int)
```

## Fonction avec valeur de retour

Une fonction peut **renvoyer une valeur** avec le mot-cl√© `return`. Reprenons notre m√©taphore de la ¬´ petite machine ¬ª : parfois, on lui demande simplement d'agir (afficher un texte), parfois on lui demande de calculer et de nous rapporter un r√©sultat.

```csharp
int Somme(int a, int b)
{
    int resultat = a + b;
    return resultat;
}
```

üí° **Astuce de lecture** : le type plac√© avant le nom de la fonction (`int` ici) annonce la nature de la valeur promise en retour. Si la fonction ne renvoie rien, on √©crit `void`.

Pour utiliser la valeur renvoy√©e :
```csharp
int total = Somme(5, 3);
Console.WriteLine(total);  // Affiche 8
```

## Le passage de param√®tres

Quand on appelle une fonction, on lui ¬´ apporte ¬ª des informations: ce sont les param√®tres. Deux mani√®res principales existent pour les transmettre, et elles ne racontent pas la m√™me histoire.

### Comportement par d√©faut : passage par valeur

En C#, **le passage par valeur est le comportement par d√©faut**. Cela signifie que :
- Par valeur: on donne une copie. La fonction travaille sur son exemplaire √† elle.
- Par r√©f√©rence: on donne un lien vers l'original. La fonction peut alors modifier la chose d'origine.

Pour forcer un passage par r√©f√©rence, il faut explicitement utiliser les mots-cl√©s `ref` ou `out`.

M√©taphore: pr√™ter un livre
- Par valeur (d√©faut), c'est comme donner une photocopie: si l'autre surligne, votre livre reste intact.
- Par r√©f√©rence (avec `ref` ou `out`), c'est pr√™ter votre vrai livre: s'il est annot√©, votre exemplaire change.

### Par valeur

La fonction re√ßoit une **copie** du param√®tre, les modifications sont locales seulement.

```csharp
void Increment(int nombre)
{
    nombre++;  // Modification locale uniquement
    Console.WriteLine("Dans la fonction : " + nombre);
}

int x = 5;
Increment(x);
Console.WriteLine("Apr√®s appel : " + x);  // Affiche toujours 5
```

### Par r√©f√©rence

La variable locale et le param√®tre partagent la m√™me instance. On utilise `ref` ou `out`.

#### Diff√©rence entre ref et out

**`ref` (r√©f√©rence)** :
- La variable **doit √™tre initialis√©e** avant l'appel de la fonction
- La fonction peut lire ET modifier la valeur
- Utilis√© quand on veut modifier une variable existante

**`out` (sortie)** :
- La variable **peut ne pas √™tre initialis√©e** avant l'appel
- La fonction **doit obligatoirement** assigner une valeur au param√®tre
- Utilis√© quand la fonction doit "retourner" plusieurs valeurs

#### Avec ref

```csharp
void Increment(ref int nombre)
{
    nombre++;  // Modifie la variable d'origine
}

int x = 5;
Increment(ref x);
Console.WriteLine(x);  // Affiche 6
```

:::: tip Erreurs fr√©quentes
- Oublier d‚Äô√©crire `ref` √† l‚Äôappel comme dans la d√©finition: `Increment(ref x)`.
- Confondre ¬´ modifier la chose ¬ª et ¬´ changer vers une nouvelle chose ¬ª: sur un type r√©f√©rence, on peut modifier l‚Äôobjet point√© m√™me si on a pass√© ¬´ par valeur ¬ª (voir plus bas).
- Utiliser `out` sans initialiser la variable √† l‚Äôappel: c‚Äôest normal, `out` promet qu‚Äôelle sera assign√©e dans la fonction.
::::

### Visualisation du passage de param√®tres (version haute et compacte)

```mermaid
%%{init: {'flowchart': {'useMaxWidth': false, 'rankSpacing': 90, 'nodeSpacing': 20}}}%%
flowchart LR
    subgraph Passage_par_valeur
        direction TB
        A1[Appelant: x = 5]
        A2[Copie ‚Üí param√®tre]
        A3[Fonction: nombre = 5]
        A4[Fonction: nombre++ ‚Üí 6]
        A5[Appelant: x reste 5]
        A1 --> A2 --> A3 --> A4 -.-> A5
    end

    subgraph Passage_par_reference
        direction TB
        B1[Appelant: x = 5]
        B2[R√©f√©rence ‚Üí param√®tre]
        B3[Fonction: nombre = 5]
        B4[Fonction: nombre++ ‚Üí 6]
        B5[Appelant: x devient 6]
        B1 --> B2 --> B3 --> B4 --> B5
    end

    Passage_par_valeur --- Passage_par_reference


    class A1,A5,B1,B5 valeur
    class A3,A4,B3,B4 fonction

    classDef valeur fill:#4d94ff,stroke:#0047b3,stroke-width:2px,color:#fff,font-weight:bold
    classDef fonction fill:#ff9980,stroke:#cc3300,stroke-width:2px,color:#fff,font-weight:bold
```

### Reconna√Ætre le passage par valeur/r√©f√©rence d'un type valeur/r√©f√©rence

| Types \ Passage de param√®tre | Passage par valeur | Passage par r√©f√©rence |
|------------------------------|--------------------|-----------------------|
| Type valeur                  | `f(int i)`         | `f(ref int i)`        |
| Type r√©f√©rence               | `f(List<int> l)`   | `f(ref List<int> l)`  |


## Types valeur vs types r√©f√©rence

Pour bien comprendre ce qui se passe ¬´ sous le capot ¬ª, il faut se rappeler qu'il faut distinguer deux familles de types. Cette distinction explique pourquoi, parfois, une modification semble ¬´ rester ¬ª apr√®s l‚Äôappel d‚Äôune fonction‚Ä¶ et parfois pas.

Les comportements du passage de param√®tres varient selon qu'il s'agit de types valeur (int, bool, struct...) ou de types r√©f√©rence (objets, tableaux, cha√Ænes...).


### Types valeur : passage par valeur vs r√©f√©rence

Les **types valeur** (int, bool, char, double, struct...) stockent directement leur contenu dans la variable. Imaginez-les comme des bo√Ætes qui contiennent r√©ellement la valeur.

#### Passage par valeur (comportement par d√©faut)

Quand on passe un type valeur √† une fonction, C# fait une **photocopie** de la valeur :

```csharp
void TesterPassageValeur(int nombre)
{
    Console.WriteLine($"Re√ßu : {nombre}");
    nombre = 100;  // On modifie la copie
    Console.WriteLine($"Modifi√© dans fonction : {nombre}");
}

int monNombre = 42;
Console.WriteLine($"Avant appel : {monNombre}");
TesterPassageValeur(monNombre);
Console.WriteLine($"Apr√®s appel : {monNombre}");  // Toujours 42 !
```

**R√©sultat :**
```
Avant appel : 42
Re√ßu : 42
Modifi√© dans fonction : 100
Apr√®s appel : 42
```

**Pourquoi ?** La fonction a re√ßu une copie de `monNombre`. Modifier cette copie ne change pas l'original.

#### Passage par r√©f√©rence (avec `ref` ou `out`)

Avec `ref`, on donne l'**adresse** de la bo√Æte originale √† la fonction :

```csharp
void TesterPassageReference(ref int nombre)
{
    Console.WriteLine($"Re√ßu : {nombre}");
    nombre = 100;  // On modifie l'original !
    Console.WriteLine($"Modifi√© dans fonction : {nombre}");
}

int monNombre = 42;
Console.WriteLine($"Avant appel : {monNombre}");
TesterPassageReference(ref monNombre);  // N'oubliez pas 'ref' !
Console.WriteLine($"Apr√®s appel : {monNombre}");  // Maintenant 100 !
```

**R√©sultat :**
```
Avant appel : 42
Re√ßu : 42
Modifi√© dans fonction : 100
Apr√®s appel : 100
```

**M√©taphore :** C'est comme donner les cl√©s de votre maison vs donner une photo de votre maison. Avec les cl√©s (`ref`), la personne peut changer votre d√©coration !

### Types r√©f√©rence : passage par valeur vs r√©f√©rence

Les **types r√©f√©rence** (tableaux, objets, listes, strings...) fonctionnent diff√©remment. La variable ne contient pas l'objet lui-m√™me, mais une **adresse** vers l'endroit o√π l'objet est stock√© en m√©moire.

Imaginez un type r√©f√©rence comme un **marque-page** dans un livre :
- Le marque-page (la variable) indique une page
- Le contenu de la page (l'objet) existe quelque part dans le livre (la m√©moire)

```mermaid
flowchart LR
    subgraph Stack["Stack (Variables)"]
        V1["monTableau<br/>adresse: 0x1000"]
    end
    
    subgraph Heap["Heap (Objets)"]
        O1["0x1000<br/>[1, 2, 3]"]
    end
    
    V1 --> O1
    
    classDef stack fill:#e1f5fe,stroke:#2B6087,stroke-width:2px,white-space:nowrap
    classDef heap fill:#ffebe6,stroke:#CC3300,stroke-width:2px,white-space:nowrap
    classDef var fill:#4d94ff,stroke:#0047b3,stroke-width:1px,color:#fff,white-space:nowrap
    classDef obj fill:#ff9980,stroke:#cc3300,stroke-width:1px,color:#fff,white-space:nowrap
    
    class Stack stack
    class Heap heap
    class V1 var
    class O1 obj
```

#### Passage par valeur (comportement par d√©faut)

M√™me "par valeur", on peut modifier le contenu de l'objet :

```csharp
void ModifierContenu(int[] tableau)
{
    Console.WriteLine($"Tableau re√ßu : [{string.Join(", ", tableau)}]");
    tableau[0] = 999;  // On modifie le contenu √† travers la r√©f√©rence
    Console.WriteLine($"Tableau modifi√© : [{string.Join(", ", tableau)}]");
}

int[] monTableau = {1, 2, 3};
Console.WriteLine($"Avant appel : [{string.Join(", ", monTableau)}]");
ModifierContenu(monTableau);
Console.WriteLine($"Apr√®s appel : [{string.Join(", ", monTableau)}]");
```

**R√©sultat :**
```
Avant appel : [1, 2, 3]
Tableau re√ßu : [1, 2, 3]
Tableau modifi√© : [999, 2, 3]
Apr√®s appel : [999, 2, 3]
```

**Visualisation en m√©moire :**

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'fontSize': '16px', 'fontFamily': 'Arial', 'primaryColor': '#ffffff', 'primaryTextColor': '#000000', 'primaryBorderColor': '#000000', 'lineColor': '#000000', 'nodeSpacing': 50, 'rankSpacing': 80, 'subgraphTextSize': '14px' }, 'flowchart': { 'useMaxWidth': true, 'htmlLabels': true, 'curve': 'linear', 'subgraphTitleMargin': {'top': 5, 'bottom': 5}, 'width': 1000 }}}%%
flowchart TB
    subgraph Avant["üî∏ AVANT L'APPEL"]
        direction LR
        subgraph Stack1["Stack (Variables)"]
            V1["monTableau<br/>üìç 0x1000"]
        end
        subgraph Heap1["Heap (Objets)"]
            O1["0x1000<br/>[1, 2, 3]"]
        end
        V1 --> O1
    end
    
    subgraph Pendant["üî∏ PENDANT L'APPEL"]
        direction LR
        subgraph Stack2["Stack (Variables)"]
            V2["monTableau<br/>üìç 0x1000"]
            V3["tableau (param)<br/>üìç 0x1000<br/>üìã copie de l'adresse"]
        end
        subgraph Heap2["Heap (Objets)"]
            O2["0x1000<br/>[999, 2, 3]<br/>‚ö†Ô∏è Modifi√© !"]
        end
        V2 --> O2
        V3 --> O2
    end
    
    subgraph Apres["üî∏ APR√àS L'APPEL"]
        direction LR
        subgraph Stack3["Stack (Variables)"]
            V4["monTableau<br/>üìç 0x1000"]
        end
        subgraph Heap3["Heap (Objets)"]
            O3["0x1000<br/>[999, 2, 3]<br/>‚úÖ Changement permanent"]
        end
        V4 --> O3
    end
    
    Avant ==> Pendant
    Pendant ==> Apres
    
    classDef stack fill:#e1f5fe,stroke:#2B6087,stroke-width:2px,font-size:14px,color:#000
    classDef heap fill:#ffebe6,stroke:#CC3300,stroke-width:2px,font-size:14px,color:#000
    classDef var fill:#4d94ff,stroke:#0047b3,stroke-width:1px,color:#fff,font-size:13px,padding:8px
    classDef obj fill:#ff9980,stroke:#cc3300,stroke-width:1px,color:#fff,font-size:13px,padding:8px
    classDef modified fill:#ff6b6b,stroke:#d63031,stroke-width:2px,color:#fff,font-size:13px,padding:8px
    classDef phase fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,font-size:16px,color:#000
    
    class Stack1,Stack2,Stack3 stack
    class Heap1,Heap2,Heap3 heap
    class V1,V2,V3,V4 var
    class O1,O3 obj
    class O2 modified
    class Avant,Pendant,Apres phase
```

**Pourquoi √ßa marche ?** La fonction re√ßoit une copie de l'adresse, mais les deux variables pointent vers le m√™me objet en m√©moire ! Modifier l'objet via une des deux adresses affecte ce que voient les deux variables.

**Mais attention :** on ne peut pas modifier l'adresse elle-m√™me :

```csharp
void TenterChangerReference(int[] tableau)
{
    tableau = new int[] {10, 20, 30};  // Nouvelle adresse locale uniquement
    Console.WriteLine($"Nouveau tableau dans fonction : [{string.Join(", ", tableau)}]");
}

int[] monTableau = {1, 2, 3};
Console.WriteLine($"Avant appel : [{string.Join(", ", monTableau)}]");
TenterChangerReference(monTableau);
Console.WriteLine($"Apr√®s appel : [{string.Join(", ", monTableau)}]");  // Inchang√© !
```

**R√©sultat :**
```
Avant appel : [1, 2, 3]
Nouveau tableau dans fonction : [10, 20, 30]
Apr√®s appel : [1, 2, 3]
```

**Visualisation en m√©moire :**




```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'fontSize': '16px', 'fontFamily': 'Arial', 'primaryColor': '#ffffff', 'primaryTextColor': '#000000', 'primaryBorderColor': '#000000', 'lineColor': '#000000', 'nodeSpacing': 50, 'rankSpacing': 80, 'subgraphTextSize': '18px' }, 'flowchart': { 'useMaxWidth': true, 'htmlLabels': true, 'curve': 'linear' }}}%%

flowchart TB
    subgraph Avant["üî∏ AVANT L'APPEL"]
        direction LR
        subgraph Stack1["Stack (Variables)"]
            V1["monTableau<br/>üìç 0x1000"]
        end
        subgraph Heap1["Heap (Objets)"]
            O1["0x1000<br/>[1, 2, 3]"]
        end
        V1 --> O1
    end
    
    subgraph Pendant["üî∏ PENDANT L'APPEL"]
        direction LR
        subgraph Stack2["Stack (Variables)"]
            V2["monTableau<br/>üìç 0x1000<br/>üîí Inchang√©"]
            V3["tableau (param)<br/>üìç 0x2000<br/>‚ö†Ô∏è Nouvelle adresse locale"]
        end
        subgraph Heap2["Heap (Objets)"]
            O2["0x1000<br/>[1, 2, 3]<br/>üìç Objet original"]
            O3["0x2000<br/>[10, 20, 30]<br/>üÜï Nouvel objet"]
        end
        V2 --> O2
        V3 --> O3
    end
    
    subgraph Apres["üî∏ APR√àS L'APPEL"]
        direction LR
        subgraph Stack3["Stack (Variables)"]
            V4["monTableau<br/>üìç 0x1000<br/>‚úÖ Toujours la m√™me adresse"]
        end
        subgraph Heap3["Heap (Objets)"]
            O4["0x1000<br/>[1, 2, 3]<br/>‚úÖ Objet inchang√©"]
            O5["‚ùå Objet [10,20,30]<br/>üóëÔ∏è supprim√© (hors port√©e)"]
        end
        V4 --> O4
    end
    
    Avant ==> Pendant
    Pendant ==> Apres
    
    classDef stack fill:#e1f5fe,stroke:#2B6087,stroke-width:2px,font-size:14px,color:#000
    classDef heap fill:#ffebe6,stroke:#CC3300,stroke-width:2px,font-size:14px,color:#000
    classDef var fill:#4d94ff,stroke:#0047b3,stroke-width:1px,color:#fff,font-size:13px,padding:8px
    classDef varChanged fill:#ffa726,stroke:#ef6c00,stroke-width:2px,color:#fff,font-size:13px,padding:8px
    classDef obj fill:#ff9980,stroke:#cc3300,stroke-width:1px,color:#fff,font-size:13px,padding:8px
    classDef objNew fill:#66bb6a,stroke:#2e7d32,stroke-width:2px,color:#fff,font-size:13px,padding:8px
    classDef objDeleted fill:#bdbdbd,stroke:#616161,stroke-width:1px,color:#333,stroke-dasharray: 5 5,font-size:13px,padding:8px
    classDef phase fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,font-size:16px,color:#000
    
    class Stack1,Stack2,Stack3 stack
    class Heap1,Heap2,Heap3 heap
    class V1,V2,V4 var
    class V3 varChanged
    class O1,O2,O4 obj
    class O3 objNew
    class O5 objDeleted
    class Avant,Pendant,Apres phase
```

**Explication :** Dans la fonction, `tableau` re√ßoit une copie de l'adresse vers `{1, 2, 3}`. Quand on fait `tableau = new int[] {10, 20, 30}`, on change seulement la variable locale `tableau` pour qu'elle pointe vers un nouveau tableau. La variable `monTableau` dans le programme principal garde son adresse originale.

#### Passage par r√©f√©rence (avec `ref`)

Avec `ref`, on peut modifier la variable qui contient l'adresse :

```csharp
void ChangerReference(ref int[] tableau)
{
    tableau = new int[] {10, 20, 30};  // On change la variable originale
    Console.WriteLine($"Nouveau tableau : [{string.Join(", ", tableau)}]");
}

int[] monTableau = {1, 2, 3};
Console.WriteLine($"Avant appel : [{string.Join(", ", monTableau)}]");
ChangerReference(ref monTableau);
Console.WriteLine($"Apr√®s appel : [{string.Join(", ", monTableau)}]");
```

**R√©sultat :**
```
Avant appel : [1, 2, 3]
Nouveau tableau : [10, 20, 30]
Apr√®s appel : [10, 20, 30]
```

**Visualisation en m√©moire :**

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'fontSize': '16px', 'fontFamily': 'Arial', 'primaryColor': '#ffffff', 'primaryTextColor': '#000000', 'primaryBorderColor': '#000000', 'lineColor': '#000000', 'nodeSpacing': 50, 'rankSpacing': 80, 'subgraphTextSize': '18px' }, 'flowchart': { 'useMaxWidth': true, 'htmlLabels': true, 'curve': 'linear' }}}%%
flowchart TB
    subgraph Avant["üî∏ AVANT L'APPEL"]
        direction LR
        subgraph Stack1["Stack (Variables)"]
            V1["monTableau<br/>üìç 0x1000"]
        end
        subgraph Heap1["Heap (Objets)"]
            O1["0x1000<br/>[1, 2, 3]"]
        end
        V1 --> O1
    end
    
    subgraph Pendant["üî∏ PENDANT L'APPEL"]
        direction LR
        subgraph Stack2["Stack (Variables)"]
            V2["monTableau<br/>üìç 0x2000<br/>üîÑ Modifi√© directement"]
            V3["tableau (ref)<br/>üîó Alias de monTableau"]
        end
        subgraph Heap2["Heap (Objets)"]
            O2["0x1000<br/>[1, 2, 3]<br/>üìç Ancien objet"]
            O3["0x2000<br/>[10, 20, 30]<br/>üÜï Nouvel objet"]
        end
        V2 --> O3
        V3 -.-> V2
    end
    
    subgraph Apres["üî∏ APR√àS L'APPEL"]
        direction LR
        subgraph Stack3["Stack (Variables)"]
            V4["monTableau<br/>üìç 0x2000<br/>‚úÖ Nouvelle adresse permanente"]
        end
        subgraph Heap3["Heap (Objets)"]
            O4["‚ùå Ancien objet [1,2,3]<br/>üóëÔ∏è supprim√© (plus de r√©f√©rence)"]
            O5["0x2000<br/>[10, 20, 30]<br/>‚úÖ Nouvel objet actif"]
        end
        V4 --> O5
    end
    
    Avant ==> Pendant
    Pendant ==> Apres
    
    classDef stack fill:#e1f5fe,stroke:#2B6087,stroke-width:2px,font-size:14px,color:#000,white-space:nowrap
    classDef heap fill:#ffebe6,stroke:#CC3300,stroke-width:2px,font-size:14px,color:#000,white-space:nowrap
    classDef var fill:#4d94ff,stroke:#0047b3,stroke-width:1px,color:#fff,font-size:13px,padding:8px,white-space:nowrap
    classDef varRef fill:#9c27b0,stroke:#6a1b9a,stroke-width:2px,color:#fff,font-size:13px,padding:8px,white-space:nowrap
    classDef varChanged fill:#ff9800,stroke:#f57c00,stroke-width:2px,color:#fff,font-size:13px,padding:8px,white-space:nowrap
    classDef obj fill:#ff9980,stroke:#cc3300,stroke-width:1px,color:#fff,font-size:13px,padding:8px,white-space:nowrap
    classDef objNew fill:#66bb6a,stroke:#2e7d32,stroke-width:2px,color:#fff,font-size:13px,padding:8px,white-space:nowrap
    classDef objDeleted fill:#bdbdbd,stroke:#616161,stroke-width:1px,color:#333,stroke-dasharray: 5 5,font-size:13px,padding:8px,white-space:nowrap
    classDef phase fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,font-size:16px,color:#000,white-space:nowrap
    
    class Stack1,Stack2,Stack3 stack
    class Heap1,Heap2,Heap3 heap
    class V1 var
    class V2,V4 varChanged
    class V3 varRef
    class O1,O2 obj
    class O3,O5 objNew
    class O4 objDeleted
    class Avant,Pendant,Apres phase
```

**Explication :** Avec `ref`, la fonction re√ßoit un acc√®s direct √† la variable `monTableau` elle-m√™me. Elle peut donc changer ce vers quoi pointe cette variable. Le param√®tre `tableau` n'est pas une copie, mais un **alias** de `monTableau`.

**R√©sum√© des comportements :**
- **Types valeur par valeur** : copie de la valeur ‚Üí modifications locales seulement
- **Types valeur par r√©f√©rence** : acc√®s direct √† la variable ‚Üí modifications permanentes
- **Types r√©f√©rence par valeur** : copie de l'adresse ‚Üí peut modifier l'objet, pas la variable
- **Types r√©f√©rence par r√©f√©rence** : acc√®s direct √† la variable ET √† l'objet ‚Üí contr√¥le total


### Exemple concret avec tableau

Voici comment les tableaux (types r√©f√©rence) se comportent avec diff√©rentes approches :

```csharp
// Modification du tableau original
void ModifierTableau(int[] param)
{
    param[2] = 9;  // Modifie le tableau original
}

// Cr√©ation d'un nouveau tableau
void ModifierNouveauTableau(int[] param)
{
    int[] nouveauArr = new int[] {param[0], param[1], 9};
    // nouveauArr pointe vers un nouveau tableau
    // param n'est pas modifi√©
}

// Dans le programme principal
int[] arr = new int[] {1, 2, 3};
ModifierTableau(arr);
Console.WriteLine(arr[2]);  // Affiche 9 (modifi√©)

arr = new int[] {1, 2, 3};
ModifierNouveauTableau(arr);
Console.WriteLine(arr[2]);  // Affiche 3 (non modifi√©)
```

```mermaid
flowchart LR
    %% Ce qui se passe dans le programme
    subgraph prog["Programme"]
        direction TB
        P1["Main: int[] arr = [1,2,3]"] --> P2["ModifierTableau(arr)"]
        P3["arr devient [1,2,9]"] --- P2

        P4["Main: int[] arr = [1,2,3]"] --> P5["ModifierNouveauTableau(arr)"]
        P6["arr reste [1,2,3]"] --- P5
    end

    %% Explication m√©moire
    subgraph "M√©moire"
        direction TB
        subgraph "Stack"
            S1["arr (r√©f√©rence)"]
            S2["param (copie de la r√©f√©rence)"]
            S3["nouveauArr (nouvelle r√©f√©rence)"]
        end

        subgraph "Heap"
            H1["Tableau [1,2,3]"]
            H2["Tableau [1,2,9]"]
            H3["Nouveau tableau [1,2,9]"]
        end

        %% Connexions
        S1 --> H1
        S2 --> H1
        S2 --> H2
        S3 --> H3
    end



    %% Styles
    classDef program fill:#f9f9f9,stroke:#333,stroke-width:1px
    classDef stack fill:#e1f5fe,stroke:#2B6087,stroke-width:1px
    classDef heap fill:#ffebe6,stroke:#CC3300,stroke-width:1px
    classDef code fill:#4d94ff,stroke:#0047b3,stroke-width:2px,color:#fff,font-weight:bold
    classDef memory fill:#5cd65c,stroke:#267326,stroke-width:2px,color:#fff,font-weight:bold
    classDef heapObj fill:#ff9980,stroke:#cc3300,stroke-width:2px,color:#fff,font-weight:bold

    class Programme program
    class Stack stack
    class Heap heap
    class P1,P2,P3,P4,P5,P6 code
    class S1,S2,S3 memory
    class H1,H2,H3 heapObj
```

::: tip Points importants √† retenir
1. **Types valeur** (int, bool, char, struct...) :
   - Pass√©s par valeur : la fonction re√ßoit une copie, les modifications sont locales
   - Pass√©s par r√©f√©rence (ref/out) : la fonction modifie la variable originale

2. **Types r√©f√©rence** (tableaux, objets, listes...) :
   - Pass√©s par valeur : la fonction re√ßoit une copie de la r√©f√©rence, mais peut modifier l'objet original
   - Pass√©s par r√©f√©rence (ref/out) : la fonction peut changer la r√©f√©rence elle-m√™me
:::

### Quand utiliser le passage par r√©f√©rence ?

- Pour modifier plusieurs valeurs dans une fonction
- Pour √©viter la copie de grandes structures de donn√©es
- Pour retourner plusieurs valeurs depuis une fonction

```csharp
void CalculerStatistiques(int[] donnees, out double moyenne, out double ecartType)
{
    moyenne = donnees.Average();
    
    double sommeCarres = 0;
    foreach (int valeur in donnees)
    {
        sommeCarres += Math.Pow(valeur - moyenne, 2);
    }
    
    ecartType = Math.Sqrt(sommeCarres / donnees.Length);
}

// Utilisation:
int[] mesures = new int[] {5, 7, 9, 12, 15};
double moy, ecart;
CalculerStatistiques(mesures, out moy, out ecart);
Console.WriteLine($"Moyenne: {moy}, √âcart-type: {ecart}");
```

#### Avec out

```csharp
void ObtenirDonnees(out int valeur)
{
    valeur = 42;  // Doit obligatoirement assigner une valeur
}

int resultat;  // Pas besoin d'initialiser avec out
ObtenirDonnees(out resultat);
Console.WriteLine(resultat);  // Affiche 42
```

#### Exemple comparatif ref vs out

```csharp
// Avec ref : variable doit √™tre initialis√©e
void DoublerAvecRef(ref int nombre)
{
    Console.WriteLine($"Valeur re√ßue : {nombre}");  // Peut lire la valeur
    nombre = nombre * 2;  // Modifie la valeur
}

// Avec out : variable sera initialis√©e dans la fonction
void CreerNombreAvecOut(out int nombre)
{
    // Console.WriteLine(nombre);  // ERREUR! Ne peut pas lire avant d'assigner
    nombre = 100;  // Doit obligatoirement assigner
}

// Utilisation
int x = 5;  // Doit √™tre initialis√© pour ref
DoublerAvecRef(ref x);
Console.WriteLine(x);  // Affiche 10

int y;  // Pas besoin d'initialiser pour out
CreerNombreAvecOut(out y);
Console.WriteLine(y);  // Affiche 100
```

::: warning Diff√©rence entre ref et out
- `ref` : la variable **doit √™tre initialis√©e** avant l'appel et peut √™tre lue dans la fonction
- `out` : la variable **peut ne pas √™tre initialis√©e** avant l'appel, mais **doit obligatoirement** recevoir une valeur dans la fonction
:::

## Param√®tres optionnels

```csharp
void Message(string texte, bool majuscules = false)
{
    if (majuscules)
    {
        Console.WriteLine(texte.ToUpper());
    }
    else
    {
        Console.WriteLine(texte);
    }
}
```

Utilisation :
```csharp
Message("Hello");  // Param√®tre optionnel non fourni
Message("Hello", true);  // Param√®tre optionnel fourni
```

## Param√®tres nomm√©s

Les **param√®tres nomm√©s** permettent de sp√©cifier explicitement le nom du param√®tre lors de l'appel d'une fonction. Cela am√©liore la lisibilit√© du code et permet de passer les param√®tres dans n'importe quel ordre.

### Syntaxe

```csharp
void CreerPersonne(string nom, string prenom, int age, string ville = "Inconnue")
{
    Console.WriteLine($"{prenom} {nom}, {age} ans, habite √† {ville}");
}
```

### Appel avec param√®tres nomm√©s

```csharp
// Appel classique (ordre des param√®tres important)
CreerPersonne("Dupont", "Jean", 25, "Bruxelles");

// Appel avec param√®tres nomm√©s (ordre libre)
CreerPersonne(age: 25, nom: "Dupont", prenom: "Jean", ville: "Bruxelles");

// M√©lange param√®tres positionnels et nomm√©s
CreerPersonne("Dupont", "Jean", age: 25, ville: "Bruxelles");

// Avec param√®tre optionnel omis
CreerPersonne(nom: "Martin", prenom: "Marie", age: 30);
```

### Avantages des param√®tres nomm√©s

1. **Clart√© du code** : le nom du param√®tre indique explicitement ce que repr√©sente la valeur
   ```csharp
   // Peu clair
   CalculerPrix(100, 0.21, true, false);
   
   // Beaucoup plus clair
   CalculerPrix(montant: 100, tva: 0.21, inclureTva: true, appliquerRemise: false);
   ```

2. **Ordre flexible** : possibilit√© de passer les param√®tres dans n'importe quel ordre
   ```csharp
   void ConfigurerServeur(string host, int port, bool ssl, string database)
   {
       // Configuration du serveur
   }
   
   // Ordre des param√®tres libre avec noms
   ConfigurerServeur(ssl: true, database: "mydb", host: "localhost", port: 8080);
   ```

3. **S√©curit√©** : √©vite les erreurs dues √† l'inversion de param√®tres de m√™me type
   ```csharp
   void DeplacerPoint(int x, int y)
   {
       Console.WriteLine($"D√©placement vers ({x}, {y})");
   }
   
   // Risque d'erreur
   DeplacerPoint(5, 10);  // x=5, y=10 ou x=10, y=5 ?
   
   // Pas d'ambigu√Øt√©
   DeplacerPoint(x: 5, y: 10);  // Clairement x=5, y=10
   ```

### R√®gles importantes

- Les param√®tres positionnels doivent venir **avant** les param√®tres nomm√©s
- Une fois qu'un param√®tre nomm√© est utilis√©, tous les suivants doivent aussi √™tre nomm√©s

```csharp
// ‚úÖ Correct
MaFonction(param1, param2, nom3: valeur3, nom4: valeur4);

// ‚ùå Incorrect - param√®tre positionnel apr√®s un param√®tre nomm√©
MaFonction(param1, nom2: valeur2, param3, nom4: valeur4);
```

## Surcharge de fonction

La **surcharge** permet de d√©finir plusieurs fonctions avec le m√™me nom mais des param√®tres diff√©rents.

```csharp
int Addition(int a, int b)
{
    return a + b;
}

double Addition(double a, double b)
{
    return a + b;
}
```

Le compilateur choisit automatiquement la bonne fonction selon les types des arguments.

## Fonctions r√©cursives

Une fonction **r√©cursive** est une fonction qui s'appelle elle-m√™me pour r√©soudre un probl√®me. C'est comme une poup√©e russe : pour ouvrir une grande poup√©e, on ouvre une plus petite √† l'int√©rieur, puis une encore plus petite, jusqu'√† arriver √† la plus petite qui ne contient plus rien.

### Principe fondamental

Toute fonction r√©cursive doit respecter deux r√®gles absolues :

1. **Cas de base** (condition d'arr√™t) : une situation o√π la fonction ne s'appelle plus elle-m√™me
2. **R√©duction du probl√®me** : √† chaque appel, le probl√®me doit devenir plus simple et se rapprocher du cas de base

### Exemple simple : compte √† rebours

Commen√ßons par un exemple tr√®s simple pour comprendre le m√©canisme :

```csharp
void CompteARebours(int n)
{
    // Cas de base : on s'arr√™te √† 0
    if (n <= 0)
    {
        Console.WriteLine("Fini !");
        return;
    }
    
    // Action pour le niveau actuel
    Console.WriteLine(n);
    
    // Appel r√©cursif avec un probl√®me plus petit
    CompteARebours(n - 1);
}
```

**Trace d'ex√©cution pour `CompteARebours(3)` :**

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'fontSize': '14px', 'fontFamily': 'Arial', 'primaryColor': '#ffffff', 'primaryTextColor': '#000000', 'primaryBorderColor': '#000000', 'lineColor': '#000000' }}}%%
flowchart TD
    A["CompteARebours(3)<br/>üìù Affiche: 3"] --> B["CompteARebours(2)<br/>üìù Affiche: 2"]
    B --> C["CompteARebours(1)<br/>üìù Affiche: 1"]
    C --> D["CompteARebours(0)<br/>üìù Affiche: Fini!<br/>üõë STOP"]
    
    D --> E["Retour vers (1)"]
    E --> F["Retour vers (2)"]
    F --> G["Retour vers (3)"]
    G --> H["Retour vers Main()"]
    
    classDef call fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,color:#000,white-space:nowrap
    classDef return fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#000,white-space:nowrap
    classDef stop fill:#ffebee,stroke:#d32f2f,stroke-width:2px,color:#000,white-space:nowrap
    
    class A,B,C call
    class D stop
    class E,F,G,H return
```

**Sortie console :**
```
3
2
1
Fini !
```

### La pile d'appels en action

Quand une fonction s'appelle elle-m√™me, chaque appel cr√©e une nouvelle "couche" dans la **pile d'appels**. Visualisons ce qui se passe en m√©moire :

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'fontSize': '18px', 'fontFamily': 'Arial', 'primaryColor': '#ffffff', 'primaryTextColor': '#000000', 'primaryBorderColor': '#000000', 'lineColor': '#000000' }}}%%
flowchart LR
    subgraph "Phase 1: Empilement des appels"
        direction TB
        P1["üìû CompteARebours(3)<br/>n = 3<br/>üëÄ Affiche 3<br/>üîÑ Appelle CompteARebours(2)"]
        P2["üìû CompteARebours(2)<br/>n = 2<br/>üëÄ Affiche 2<br/>üîÑ Appelle CompteARebours(1)"]
        P3["üìû CompteARebours(1)<br/>n = 1<br/>üëÄ Affiche 1<br/>üîÑ Appelle CompteARebours(0)"]
        P4["üìû CompteARebours(0)<br/>n = 0<br/>üëÄ Affiche 'Fini!'<br/>üõë return (cas de base)<br>"]
        P1 -.-> P2
        P2 -.-> P3
        P3 -.-> P4
    end
    
    subgraph "Phase 2: D√©pilement et retours"
        direction TB
        R4["‚úÖ CompteARebours(0)<br/>termin√©"]
        R3["‚úÖ CompteARebours(1)<br/>termin√©"]
        R2["‚úÖ CompteARebours(2)<br/>termin√©"]
        R1["‚úÖ CompteARebours(3)<br/>termin√©"]
        R4 --> R3
        R3 --> R2
        R2 --> R1
    end
    
    classDef calling fill:#e8f5e8,stroke:#4caf50,stroke-width:2px,color:#000,white-space:nowrap
    classDef base fill:#ffebee,stroke:#f44336,stroke-width:2px,color:#000,white-space:nowrap
    classDef returning fill:#e3f2fd,stroke:#2196f3,stroke-width:2px,color:#000,white-space:nowrap
    
    class P1,P2,P3 calling
    class P4 base
    class R1,R2,R3,R4 returning
```

### Exemple d√©taill√© : calcul de factorielle

La factorielle est un exemple classique de r√©cursion. Rappel math√©matique :
- `5! = 5 √ó 4 √ó 3 √ó 2 √ó 1 = 120`
- `n! = n √ó (n-1)!`
- `0! = 1` et `1! = 1` (cas de base)

```csharp
int Factorielle(int n)
{
    // Cas de base : factorielle de 0 ou 1 vaut 1
    if (n <= 1)
    {
        Console.WriteLine($"Cas de base : {n}! = 1");
        return 1;
    }
    
    // Cas r√©cursif : n! = n √ó (n-1)!
    Console.WriteLine($"Calcul de {n}! = {n} √ó {n-1}!");
    int resultatSousProbleme = Factorielle(n - 1);
    int resultatActuel = n * resultatSousProbleme;
    Console.WriteLine($"Retour : {n}! = {n} √ó {resultatSousProbleme} = {resultatActuel}");
    
    return resultatActuel;
}
```

**Trace compl√®te pour `Factorielle(4)` :**

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'fontSize': '12px', 'fontFamily': 'Arial', 'primaryColor': '#ffffff', 'primaryTextColor': '#000000', 'primaryBorderColor': '#000000', 'lineColor': '#000000' }}}%%
flowchart TD
    subgraph "üîΩ Phase DESCENTE (empilement)"
        A["Factorielle(4)<br/>üìù 'Calcul de 4! = 4 √ó 3!'<br/>üîÑ Appelle Factorielle(3)"]
        B["Factorielle(3)<br/>üìù 'Calcul de 3! = 3 √ó 2!'<br/>üîÑ Appelle Factorielle(2)"]
        C["Factorielle(2)<br/>üìù 'Calcul de 2! = 2 √ó 1!'<br/>üîÑ Appelle Factorielle(1)"]
        D["Factorielle(1)<br/>üìù 'Cas de base : 1! = 1'<br/>üîô return 1"]
        
        A --> B
        B --> C
        C --> D
    end
    
    subgraph "üîº Phase REMONT√âE (d√©pilement)"
        E["Factorielle(2)<br/>üìù 'Retour : 2! = 2 √ó 1 = 2'<br/>üîô return 2"]
        F["Factorielle(3)<br/>üìù 'Retour : 3! = 3 √ó 2 = 6'<br/>üîô return 6"]
        G["Factorielle(4)<br/>üìù 'Retour : 4! = 4 √ó 6 = 24'<br/>üîô return 24"]
        
        D --> E
        E --> F
        F --> G
    end
    
    classDef descent fill:#e8f5e8,stroke:#4caf50,stroke-width:2px,color:#000,white-space:nowrap
    classDef base fill:#ffebee,stroke:#f44336,stroke-width:2px,color:#000,white-space:nowrap
    classDef ascent fill:#e3f2fd,stroke:#2196f3,stroke-width:2px,color:#000,white-space:nowrap
    
    class A,B,C descent
    class D base
    class E,F,G ascent
```

**Sortie console compl√®te :**
```
Calcul de 4! = 4 √ó 3!
Calcul de 3! = 3 √ó 2!
Calcul de 2! = 2 √ó 1!
Cas de base : 1! = 1
Retour : 2! = 2 √ó 1 = 2
Retour : 3! = 3 √ó 2 = 6
Retour : 4! = 4 √ó 6 = 24
```

### Visualisation de la pile d'appels avec les variables

Voyons comment les variables locales s'accumulent dans la pile :

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'fontSize': '13px', 'fontFamily': 'Arial', 'primaryColor': '#ffffff', 'primaryTextColor': '#000000', 'primaryBorderColor': '#000000', 'lineColor': '#000000' }}}%%
flowchart TB
    subgraph "üèóÔ∏è √âtat de la pile au moment le plus profond"
        direction TB
        S4["üü¶ Factorielle(4)<br/>üìã n = 4<br/>‚è≥ En attente de Factorielle(3)"]
        S3["üü© Factorielle(3)<br/>üìã n = 3<br/>‚è≥ En attente de Factorielle(2)"]
        S2["üü® Factorielle(2)<br/>üìã n = 2<br/>‚è≥ En attente de Factorielle(1)"]
        S1["üü• Factorielle(1)<br/>üìã n = 1<br/>‚úÖ Cas de base : return 1"]
        
        S1 --> S2
        S2 --> S3
        S3 --> S4
        
        style S4 fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
        style S3 fill:#e8f5e8,stroke:#388e3c,stroke-width:2px
        style S2 fill:#fff3e0,stroke:#f57c00,stroke-width:2px
        style S1 fill:#ffebee,stroke:#d32f2f,stroke-width:2px
    end
    
    subgraph "üîÑ Puis d√©pilement progressif"
        direction TB
        D1["üü• return 1"] 
        D2["üü® re√ßoit 1<br/>calcule 2√ó1=2<br/>return 2"]
        D3["üü© re√ßoit 2<br/>calcule 3√ó2=6<br/>return 6"]
        D4["üü¶ re√ßoit 6<br/>calcule 4√ó6=24<br/>return 24"]
        
        D1 --> D2
        D2 --> D3
        D3 --> D4
        
        style D1 fill:#ffebee,stroke:#d32f2f,stroke-width:2px,white-space:nowrap
        style D2 fill:#fff3e0,stroke:#f57c00,stroke-width:2px,white-space:nowrap
        style D3 fill:#e8f5e8,stroke:#388e3c,stroke-width:2px,white-space:nowrap
        style D4 fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,white-space:nowrap
    end
```

### Exemple avec accumulation : somme des nombres

Voici un autre exemple pour bien comprendre comment les valeurs s'accumulent :

```csharp
int SommeJusquA(int n)
{
    // Cas de base
    if (n <= 0)
    {
        Console.WriteLine("Cas de base : somme jusqu'√† 0 = 0");
        return 0;
    }
    
    // Cas r√©cursif : somme(n) = n + somme(n-1)
    Console.WriteLine($"Calcul : somme({n}) = {n} + somme({n-1})");
    int sommeReste = SommeJusquA(n - 1);
    int resultat = n + sommeReste;
    Console.WriteLine($"Retour : somme({n}) = {n} + {sommeReste} = {resultat}");
    
    return resultat;
}
```

**Pour `SommeJusquA(4)` (calcule 4+3+2+1+0) :**

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'fontSize': '16px', 'fontFamily': 'Arial', 'primaryColor': '#ffffff', 'primaryTextColor': '#000000', 'primaryBorderColor': '#000000', 'lineColor': '#000000' }}}%%
graph TD
    A["SommeJusquA(4)<br/>üßÆ 4 + SommeJusquA(3)"] --> B["SommeJusquA(3)<br/>üßÆ 3 + SommeJusquA(2)"]
    B --> C["SommeJusquA(2)<br/>üßÆ 2 + SommeJusquA(1)"]
    C --> D["SommeJusquA(1)<br/>üßÆ 1 + SommeJusquA(0)"]
    D --> E["SommeJusquA(0)<br/>üîö return 0"]
    
    E -.-> F["1 + 0 = 1<br/>üîô return 1"]
    F -.-> G["2 + 1 = 3<br/>üîô return 3"]
    G -.-> H["3 + 3 = 6<br/>üîô return 6"]
    H -.-> I["4 + 6 = 10<br/>üîô return 10"]
    
    classDef down fill:#ffcdd2,stroke:#d32f2f,stroke-width:2px,color:#000,padding:50px,white-space:nowrap
    classDef base fill:#dcedc8,stroke:#689f38,stroke-width:2px,color:#000,padding:50px,white-space:nowrap
    classDef up fill:#bbdefb,stroke:#1976d2,stroke-width:2px,color:#000,padding:50px,white-space:nowrap
    
    class A,B,C,D down
    class E base
    class F,G,H,I up
```

### R√©cursion avec cha√Ænes de caract√®res

Exemple d'inversion d'une cha√Æne de caract√®res :

```csharp
string InverserChaine(string texte)
{
    // Cas de base : cha√Æne vide ou un seul caract√®re
    if (texte.Length <= 1)
    {
        Console.WriteLine($"Cas de base : '{texte}' -> '{texte}'");
        return texte;
    }
    
    // Cas r√©cursif : dernier caract√®re + inversion du reste
    char premierChar = texte[0];
    string reste = texte.Substring(1);
    
    Console.WriteLine($"Traitement de '{texte}' : '{premierChar}' + inverser('{reste}')");
    
    string resteInverse = InverserChaine(reste);
    string resultat = resteInverse + premierChar;
    
    Console.WriteLine($"Retour : inverser('{reste}') + '{premierChar}' = '{resteInverse}' + '{premierChar}' = '{resultat}'");
    
    return resultat;
}
```

**Pour `InverserChaine("ABC")` :**

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'fontSize': '12px', 'fontFamily': 'Arial', 'primaryColor': '#ffffff', 'primaryTextColor': '#000000', 'primaryBorderColor': '#000000', 'lineColor': '#000000' }}}%%
flowchart TD
    A["InverserChaine('ABC')<br/>üî§ 'A' + InverserChaine('BC')"]
    B["InverserChaine('BC')<br/>üî§ 'B' + InverserChaine('C')"]
    C["InverserChaine('C')<br/>üîö Cas de base : return 'C'"]
    
    D["'C' + 'B' = 'CB'<br/>üîô return 'CB'"]
    E["'CB' + 'A' = 'CBA'<br/>üîô return 'CBA'"]
    
    A --> B
    B --> C
    C -.-> D
    D -.-> E
    
    classDef process fill:#e1f5fe,stroke:#0277bd,stroke-width:2px,color:#000
    classDef base fill:#e8f5e8,stroke:#388e3c,stroke-width:2px,color:#000
    classDef result fill:#fff3e0,stroke:#f57c00,stroke-width:2px,color:#000
    
    class A,B process
    class C base
    class D,E result
```

### R√©cursion avec structures conditionnelles : nombre de Fibonacci

Les nombres de Fibonacci illustrent une r√©cursion avec deux appels :

```csharp
int Fibonacci(int n)
{
    // Affichage pour comprendre l'ex√©cution
    Console.WriteLine($"  {"".PadLeft(n * 2)}Fibonacci({n})");
    
    // Cas de base
    if (n <= 1)
    {
        Console.WriteLine($"  {"".PadLeft(n * 2)}-> Cas de base : Fibonacci({n}) = {n}");
        return n;
    }
    
    // Cas r√©cursif : F(n) = F(n-1) + F(n-2)
    Console.WriteLine($"  {"".PadLeft(n * 2)}-> Fibonacci({n}) = Fibonacci({n-1}) + Fibonacci({n-2})");
    
    int fib1 = Fibonacci(n - 1);
    int fib2 = Fibonacci(n - 2);
    int resultat = fib1 + fib2;
    
    Console.WriteLine($"  {"".PadLeft(n * 2)}-> Fibonacci({n}) = {fib1} + {fib2} = {resultat}");
    
    return resultat;
}
```

**Arbre d'appels pour `Fibonacci(4)` :**

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'fontSize': '11px', 'fontFamily': 'Arial', 'primaryColor': '#ffffff', 'primaryTextColor': '#000000', 'primaryBorderColor': '#000000', 'lineColor': '#000000' }}}%%
graph TD
    A["Fibonacci(4)<br/>F(3) + F(2)"]
    
    B["Fibonacci(3)<br/>F(2) + F(1)"]
    C["Fibonacci(2)<br/>F(1) + F(0)"]
    
    D["Fibonacci(2)<br/>F(1) + F(0)"]
    E["Fibonacci(1)<br/>üîö return 1"]
    F["Fibonacci(1)<br/>üîö return 1"]
    G["Fibonacci(0)<br/>üîö return 0"]
    H["Fibonacci(1)<br/>üîö return 1"]
    I["Fibonacci(0)<br/>üîö return 0"]
    
    A --> B
    A --> C
    B --> D
    B --> E
    C --> F
    C --> G
    D --> H
    D --> I
    
    classDef internal fill:#e3f2fd,stroke:#1976d2,stroke-width:2px,color:#000
    classDef base fill:#e8f5e8,stroke:#388e3c,stroke-width:2px,color:#000
    
    class A,B,C,D internal
    class E,F,G,H,I base
```

### Erreurs courantes et d√©bogage

#### 1. Oubli du cas de base

```csharp
// ‚ùå ERREUR : r√©cursion infinie !
int MauvaisComptage(int n)
{
    Console.WriteLine(n);
    return MauvaisComptage(n - 1);  // Pas de condition d'arr√™t !
}
```

**R√©sultat :** `StackOverflowException` - La pile d'appels d√©borde.

#### 2. Cas de base incorrect

```csharp
// ‚ùå ERREUR : condition mal formul√©e
int FactorielleBuggee(int n)
{
    if (n == 1)  // Que se passe-t-il si n = 0 ?
        return 1;
    return n * FactorielleBuggee(n - 1);
}
```

**Probl√®me :** Si on appelle `FactorielleBuggee(0)`, le cas de base n'est jamais atteint !

#### 3. Progression incorrete vers le cas de base

```csharp
// ‚ùå ERREUR : n ne diminue jamais
int ProgressionIncorrecte(int n)
{
    if (n <= 0)
        return 0;
    return n + ProgressionIncorrecte(n);  // Oups ! Devrait √™tre n-1
}
```

### Conseils pour bien √©crire une fonction r√©cursive

1. **Identifiez le cas de base d'abord** : quand doit-on s'arr√™ter ?
2. **V√©rifiez la progression** : le param√®tre se rapproche-t-il toujours du cas de base ?
3. **Testez avec de petites valeurs** : commencez par n=0, n=1, n=2...
4. **Ajoutez des traces** : utilisez `Console.WriteLine` pour voir ce qui se passe
5. **Pensez "diviser pour r√©gner"** : comment d√©composer le probl√®me en sous-probl√®mes plus simples ?

### R√©cursion vs it√©ration

Souvent, un probl√®me r√©cursif peut aussi √™tre r√©solu de mani√®re it√©rative :

```csharp
// Version r√©cursive de la factorielle
int FactorielleRecursive(int n)
{
    if (n <= 1) return 1;
    return n * FactorielleRecursive(n - 1);
}

// Version it√©rative de la factorielle
int FactorielleIterative(int n)
{
    int resultat = 1;
    for (int i = 2; i <= n; i++)
    {
        resultat *= i;
    }
    return resultat;
}
```

**Quand utiliser la r√©cursion ?**
- Quand le probl√®me se d√©compose naturellement en sous-probl√®mes similaires
- Pour des structures d'arbre ou des algorithmes "diviser pour r√©gner"
- Quand la solution r√©cursive est plus claire et plus facile √† comprendre

**Quand √©viter la r√©cursion ?**
- Pour de tr√®s grandes valeurs (risque de d√©bordement de pile)
- Quand la version it√©rative est beaucoup plus efficace
- Quand il y a beaucoup de calculs redondants (comme Fibonacci na√Øf)

::: danger Attention
Les fonctions r√©cursives doivent toujours avoir :
- **Un cas de base** clairement d√©fini
- **Une progression** vers ce cas de base √† chaque appel r√©cursif
- **Une limite raisonnable** pour √©viter le d√©bordement de pile (`StackOverflowException`)
:::

::: tip D√©bogage de la r√©cursion
Pour comprendre une fonction r√©cursive qui ne fonctionne pas :
1. Ajoutez des `Console.WriteLine` avec le niveau d'indentation
2. V√©rifiez que le cas de base est atteint
3. Tracez les valeurs des param√®tres √† chaque appel
4. Testez avec les plus petites valeurs possibles
:::

## Fonctions anonymes et expressions lambda

Les fonctions anonymes et expressions lambda permettent de d√©finir des fonctions sans nom.

```csharp
// Fonction anonyme
Func<int, int, int> addition = delegate(int a, int b) { return a + b; };

// Expression lambda √©quivalente
Func<int, int, int> addition = (a, b) => a + b;

Console.WriteLine(addition(5, 3));  // Affiche 8
```

## En r√©sum√©

- Une fonction est une pi√®ce de code qui porte un nom, peut recevoir des param√®tres et, parfois, rend une valeur avec `return`.
- **Le passage par valeur est le comportement par d√©faut** en C# : la fonction re√ßoit une copie des param√®tres.
- Pour un passage par r√©f√©rence, il faut explicitement utiliser `ref` ou `out` :
  - `ref` : la variable doit √™tre initialis√©e avant l'appel, la fonction peut la lire et la modifier
  - `out` : la variable peut ne pas √™tre initialis√©e, mais la fonction doit obligatoirement lui assigner une valeur
- Les **param√®tres nomm√©s** permettent d'appeler une fonction en sp√©cifiant explicitement le nom des param√®tres (ex: `f(a: 5, b: 10)`), am√©liorant la lisibilit√© et permettant un ordre flexible.
- Les types valeur (int, bool, struct) se comportent diff√©remment des types r√©f√©rence (tableaux, objets): gardez cette diff√©rence √† l'esprit.

Petite checklist avant d'√©crire une fonction
- Ai-je un nom clair qui dit ce que la fonction fait ?
- Quels param√®tres sont vraiment n√©cessaires et de quel type ?
- La fonction doit-elle renvoyer une valeur ? Laquelle ?
- Ai-je besoin d'un passage par r√©f√©rence (`ref`/`out`) ou le passage par valeur (d√©faut) suffit-il ?
- Y a-t-il des effets de bord attendus (modifications d‚Äôobjets) ? Sont-ils souhaitables et document√©s ?
